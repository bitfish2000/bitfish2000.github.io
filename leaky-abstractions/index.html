<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://bitfish.in/images/favicon.png" />
<title>Leaky abstractions | Arsalan Zaidi&#39;s Blog</title>
<meta name="title" content="Leaky abstractions" />
<meta name="description" content="TLDR: Abstractions are critical for reducing cognitive load, but you still need to know what’s going on under the hood.
The faulty plumbing behind leaky abstractions
Abstractions are critical for a software developer. There’s only so much complexity a human head can hold and the closer you are to the hardware, perversely the less you can do with it. If you’re forced to code right up against the silicon writing machine code, you’ll spend all your time and mental energy just getting simple input/output to work. All of the history of development has been about using the advantages of Moore’s law to climb up the abstraction ladder. We hide the details of how a sub-system or functionality works under a library, framework or language feature so we can ignore the specifics. We step further away from the guts of the system and climb higher up the ladder in order to get a wider view of the landscape. We try to treat functionality as opaque Lego blocks and the bigger the blocks we snap together, the bigger the structures we can build." />
<meta name="keywords" content="Software Development," />


<meta property="og:url" content="https://bitfish.in/leaky-abstractions/">
  <meta property="og:site_name" content="Arsalan Zaidi&#39;s Blog">
  <meta property="og:title" content="Leaky abstractions">
  <meta property="og:description" content="TLDR: Abstractions are critical for reducing cognitive load, but you still need to know what’s going on under the hood.
The faulty plumbing behind leaky abstractions Abstractions are critical for a software developer. There’s only so much complexity a human head can hold and the closer you are to the hardware, perversely the less you can do with it. If you’re forced to code right up against the silicon writing machine code, you’ll spend all your time and mental energy just getting simple input/output to work. All of the history of development has been about using the advantages of Moore’s law to climb up the abstraction ladder. We hide the details of how a sub-system or functionality works under a library, framework or language feature so we can ignore the specifics. We step further away from the guts of the system and climb higher up the ladder in order to get a wider view of the landscape. We try to treat functionality as opaque Lego blocks and the bigger the blocks we snap together, the bigger the structures we can build.">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2023-08-18T12:00:00+00:00">
    <meta property="article:modified_time" content="2023-08-18T12:00:00+00:00">
    <meta property="article:tag" content="Software Development">
    <meta property="og:image" content="https://bitfish.in/images/share.png">




  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://bitfish.in/images/share.png">
  <meta name="twitter:title" content="Leaky abstractions">
  <meta name="twitter:description" content="TLDR: Abstractions are critical for reducing cognitive load, but you still need to know what’s going on under the hood.
The faulty plumbing behind leaky abstractions Abstractions are critical for a software developer. There’s only so much complexity a human head can hold and the closer you are to the hardware, perversely the less you can do with it. If you’re forced to code right up against the silicon writing machine code, you’ll spend all your time and mental energy just getting simple input/output to work. All of the history of development has been about using the advantages of Moore’s law to climb up the abstraction ladder. We hide the details of how a sub-system or functionality works under a library, framework or language feature so we can ignore the specifics. We step further away from the guts of the system and climb higher up the ladder in order to get a wider view of the landscape. We try to treat functionality as opaque Lego blocks and the bigger the blocks we snap together, the bigger the structures we can build.">




  <meta itemprop="name" content="Leaky abstractions">
  <meta itemprop="description" content="TLDR: Abstractions are critical for reducing cognitive load, but you still need to know what’s going on under the hood.
The faulty plumbing behind leaky abstractions Abstractions are critical for a software developer. There’s only so much complexity a human head can hold and the closer you are to the hardware, perversely the less you can do with it. If you’re forced to code right up against the silicon writing machine code, you’ll spend all your time and mental energy just getting simple input/output to work. All of the history of development has been about using the advantages of Moore’s law to climb up the abstraction ladder. We hide the details of how a sub-system or functionality works under a library, framework or language feature so we can ignore the specifics. We step further away from the guts of the system and climb higher up the ladder in order to get a wider view of the landscape. We try to treat functionality as opaque Lego blocks and the bigger the blocks we snap together, the bigger the structures we can build.">
  <meta itemprop="datePublished" content="2023-08-18T12:00:00+00:00">
  <meta itemprop="dateModified" content="2023-08-18T12:00:00+00:00">
  <meta itemprop="wordCount" content="792">
  <meta itemprop="image" content="https://bitfish.in/images/share.png">
  <meta itemprop="keywords" content="Software Development">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
    --width: 720px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color: #8b6fcb;
    --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: #01242e;
      --heading-color: #eee;
      --text-color: #ddd;
      --link-color: #8cc2dd;
      --visited-color: #8b6fcb;
      --blockquote-color: #ccc;
    }
  }

  body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
  }

  a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  nav a {
    margin-right: 8px;
  }

  strong,
  b {
    color: var(--heading-color);
  }

  button {
    margin: 0;
    cursor: pointer;
  }

  time {
    font-family: monospace;
    font-style: normal;
    font-size: 15px;
  }

  main {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  hr {
    border: 0;
    border-top: 1px dashed;
  }

  img {
    max-width: 100%;
  }

  code {
    font-family: monospace;
    padding: 2px;
    border-radius: 3px;
  }

  blockquote {
    border-left: 1px solid #999;
    color: var(--blockquote-color);
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px 0;
    text-align: center;
  }

  .title:hover {
    text-decoration: none;
  }

  .title h1 {
    font-size: 1.5em;
  }

  .inline {
    width: auto !important;
  }

  .highlight,
  .code {
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: var(--visited-color);
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Arsalan Zaidi&#39;s Blog</h2>
</a>
<nav>
<a href="/">Home</a>

<a href="/blog/">Blog</a>

<a href="/index.xml">RSS-feed</a>

</nav>
</header>
  <main>

<h1>Leaky abstractions</h1>
<p>
  <i>
    <time datetime='2023-08-18'>
      18 Aug, 2023
    </time>
  </i>
</p>

<content>
  <p>TLDR: Abstractions are critical for reducing cognitive load, but you still need to know what’s going on under the hood.</p>
<h3 id="the-faulty-plumbing-behind-leaky-abstractions">The faulty plumbing behind leaky abstractions</h3>
<p>Abstractions are critical for a software developer. There’s only so much complexity a human head can hold and the closer you are to the hardware, perversely the less you can do with it. If you’re forced to code right up against the silicon writing machine code, you’ll spend all your time and mental energy just getting simple input/output to work. All of the history of development has been about using the advantages of Moore’s law to climb up the abstraction ladder. We hide the details of how a sub-system or functionality works under a library, framework or language feature so we can ignore the specifics. We step further away from the guts of the system and climb higher up the ladder in order to get a wider view of the landscape. We try to treat functionality as opaque Lego blocks and the bigger the blocks we snap together, the bigger the structures we can build.</p>
<p>But there’s a problem with working with abstractions. They leak. The bones poke through and the details ooze out. As much as we want to ignore the specifics of the implementation and save our mental bandwidth for other work, we’re forced to confront the underlying details.</p>
<h3 id="drip-drip-drip">Drip drip drip…</h3>
<p>Let&rsquo;s take a few examples from real life to illustrate the problem. One of the classics is trying to abstract away the details of dealing with the network. Using RPCs or NFS, we attempt to reduce the complexity of dealing with an often unreliable network infrastructure. However much like the monsters under our beds, the unreliability of the network doesn’t go away just because we decide to close our eyes and hide under the covers. Network calls may take longer than expected or fail completely which means you need to be able to be aware of and handle those error conditions. In order to understand them you need to be familiar with the details of making a call over the network. This defeats the purpose of the abstraction since now you’re exposed to the underlying complexity anyway. Even if things work according to plan 90% of the time, in order to have a robust system you need to handle the 10% when things go belly up.</p>
<p>ORMs are another case in point. The promise is that you can ignore the details of the database and treat it like an object store. Using an ORM makes 80% of your work much easier (and those are the use cases you see in the demos!) but the final 20% can become significantly harder. Edge cases where you need to do complex joins or optimise particularly heavy queries will force you to drop into SQL to solve the problem. Debugging can become markedly more difficult since now you’re one level removed from the actual database and mapping the errors to the bug in your code via the ORM can cause significant hair loss.</p>
<h3 id="put-a-bucket-under-it">Put a bucket under it</h3>
<p>So now that we understand the problem, what can we do about it? Other than whining on substack of course! What is the impact this should have on the decisions we make?</p>
<p>We can’t do away with using an abstraction layer or layers. It’s a fundamental part of coding and it’s a very successful approach. However, we need to accept that we will need to dig at least one level down the abstraction stack. We might need to go two levels down in particularly gnarly cases but that’s usually rare. This means we will need to have at least a basic understanding of the technology upon which the abstraction is built and be aware of its limitations and to some extent, its complexities. We’ll have to take a call whether the 80% part of our work which becomes easier is worth the hassle of dealing with the 20% which will become more difficult.</p>
<p>For example, I personally feel that a full fledged ORM like Hibernate gets in my way more than it helps, while something lighter like MyBatis or Spring’s JDBCTemplate is more to my taste. Recently which deciding between Terraform and CloudFormation for my Infrastructure as code needs,  I decided to go with the lower level complexity of using AWS Cloudformation directly. The reason? Looming deadlines and no time for shortcuts! I knew that if I went with Terraform instead of CloudFormation, I would have to deal with both the intricacies of both.</p>
<p>Sometimes you just need to bite the bullet and drop down a level to get work done. Abstractions can be really useful, but good luck trying to ignore the piping hidden behind the walls.</p>

</content>



<p>
  
  <a href="https://bitfish.in/blog/software-development/">#Software Development</a>
  
</p>

  </main>
  <footer>Made with <a href="https://github.com/janraasch/hugo-bearblog/">Hugo ʕ•ᴥ•ʔ Bear</a>
</footer>

  
</body>

</html>
